#!/usr/bin/python

from datetime import datetime, date, timedelta
import json
import os
import sys

from os.path import join, isdir, isfile, splitext, basename, exists, realpath, dirname


CONFIG_PATH = join(os.getenv('XDG_CONFIG_HOME'), 'tt') if os.getenv('XDG_CONFIG_HOME') else join(os.getenv('HOME'), '.config', 'tt')

DEFAULT_CONFIG = {
        'tmp_file': join(os.getenv('HOME'), 'tmp', '.timetracker'),
        'base_dir': join(os.getenv('HOME'), 'var', 'nextcloud', 'misc', 'timetracker'),
        'strf_string': '%H:%M',
        'statuses': {
            's': 'sick',
            'v': 'vacation',
            'csd': 'child-sick-day',
            'wd': 'weekday',
            'we': 'weekend'},
        'worktime': {
            'hours': 8,
            'minutes': 0},
        'delta_minutes': 0,
    }


def usage():
    print(f'Usage: {basename(sys.argv[0])} <0|1|e|t|s <s|v>>')
    sys.exit(1)


def err(msg: str):
    print(f'[!] {msg}')
    sys.exit(1)


def read_config():
    if not isfile(CONFIG_PATH): return {}
    with open(CONFIG_PATH) as config_file:
        return json.load(config_file)


class Day():
    times = []
    status = None

    def __init__(self, date: date):
        self.date = date
        self.path = join(config['base_dir'], self.date.strftime('%Y-%m'), f'{self.date.isoformat()}.md')
        self.status = config['statuses']['wd' if self.date.weekday() < 5 else 'we']

        if isfile(self.path):
            try:
                datedict = json.load(open(self.path))
                self.times = self._read_times(datedict)
                self.status = datedict.get('status')
            except:
                pass

    def _read_times(self, datedict):
        times = datedict.get('times')
        datetimes = [datetime.fromisoformat(f'{self.date}T{t}:00') for t in times]
        return datetimes

    def _log(self, delta_minutes=0):
        self.times.append(datetime.now() + timedelta(minutes=delta_minutes))

    def start_log(self):
        if isfile(config['tmp_file']):
            err('already logging')
        os.mknod(config['tmp_file'])
        delta_minutes = int(config['delta_minutes'])
        self._log(-delta_minutes)
        self.store()

    def stop_log(self):
        if not isfile(config['tmp_file']):
            err('not logging')
        delta_minutes = int(config['delta_minutes'])
        self._log(delta_minutes)
        os.remove(config['tmp_file'])
        self.store()

    def set_status(self, status):
        self.status = config['statuses'][status]
        self.store()

    def elapsed_time(self):
        tmp_times = self.times.copy()
        if len(self.times) % 2 and self.date == date.today():
            tmp_times.append(datetime.now())

        return sum((end - start for (start, end) in zip(tmp_times[0::2], tmp_times[1::2])), timedelta())

    def total_seconds(self):
        return self.elapsed_time().total_seconds()

    def store(self, path=None):
        used_path = path if path else self.path
        used_dir = os.path.dirname(os.path.realpath(used_path))

        if not isdir(used_dir):
            os.makedirs(used_dir)
        json.dump(self._dict(), open(used_path, 'w'))

    def edit(self):
        if not isfile(self.path):
            err(f'No file for {self.date}')
        os.system(f'vim {self.path}')

    def _dict(self):
        return {'date': self.date.isoformat(),
                'times': [dt.strftime(config['strf_string']) for dt in self.times],
                'status': self.status}

    def __str__(self):
        return json.dumps(self._dict(), sort_keys=True)


def matches_iso_date(string: str):
    try:
        return date.fromisoformat(string)
    except:
        return False


def print_time(seconds: int):
    print(f'{int(seconds//3600):2d}h {int((seconds%3600)//60):02d}m')



def all_dates():
    return [date.fromisoformat((splitext(f)[0])) for _,_,files in os.walk(config['base_dir']) for f in files if matches_iso_date(splitext(f)[0])]


def total():
    days = [Day(d) for d in all_dates()]
    worktime = timedelta(hours=config['worktime']['hours'], minutes=config['worktime']['minutes'])

    total_seconds = sum([d.total_seconds() for d in days]) - sum([worktime for d in days if d.status == 'weekday'], timedelta()).total_seconds()

    print_time(total_seconds)


def day_total(date_string: str = str(date.today())):
    try:
        day_date = date.fromisoformat(date_string)
    except:
        err('No datestring given')
    print_time(Day(day_date).total_seconds())


def week_total(week_number: int = date.today().isocalendar()[1]):
    week_dates = [Day(d) for d in all_dates() if d.isocalendar()[1] == week_number]
    total_seconds = sum([d.total_seconds() for d in week_dates])
    print_time(total_seconds)


if __name__ == '__main__':
    config = {**DEFAULT_CONFIG, **read_config()}

    if len(sys.argv) < 2:
        total()
    elif sys.argv[1] == '1':
        Day(date.today()).start_log()
    elif sys.argv[1] == '0':
        Day(date.today()).stop_log()
    elif sys.argv[1] == 'e':
        Day(date.today()).edit()
    elif sys.argv[1] == 't':
        total()
    elif sys.argv[1] == 'd':
        if len(sys.argv) < 3:
            day_total()
        else:
            day_total(sys.argv[2])
    elif sys.argv[1] == 'w':
        if len(sys.argv) < 3:
            week_total()
        else:
            week_total(int(sys.argv[2]))
    elif sys.argv[1] == 's':
        if len(sys.argv) < 3:
            usage()
        if sys.argv[2] == 's':
            Day(date.today()).set_status('s')
        elif sys.argv[2] == 'v':
            Day(date.today()).set_status('v')
        else:
            usage()
    else:
        usage()

